<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>timeseries &mdash; GDA Toolbox v1.0 Manual</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="GDA Toolbox v1.0 Manual" href="../index.html" >
    <link rel="up" title="Module code" href="index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../index.html">GDA Toolbox v1.0 Manual</a></li>
	
          <li class="active"><a href="index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for timeseries</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines tools for geometric analysis of one-dimensional</span>
<span class="sd">(time-series) data sets.  The main classes are</span>

<span class="sd">    - :class:`Signal`</span>
<span class="sd">    - :class:`SpaceCurve`</span>

<span class="sd">See `timeseries-data` for a more general outline.</span>

<span class="sd">Copyright</span>
<span class="sd">---------</span>
<span class="sd">- This file is part of https://github.com/geomdata/gda-public/ </span>
<span class="sd">- 2015, 2016, 2017 by Geometric Data Analytics, Inc. (http://geomdata.com)</span>
<span class="sd">- AGPL license. See `LICENSE` or https://github.com/geomdata/gda-public/blob/master/LICENSE</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">&gt;&gt;&gt; el = Signal([2.0, 3.0, 0.0, 5.0, 2.5, 2.9])</span>
<span class="sd">&gt;&gt;&gt; el.make_pers()</span>
<span class="sd">&gt;&gt;&gt; el.pers.diagram</span>
<span class="sd">   birth_index  death_index  birth  death  pers</span>
<span class="sd">0            0            1    2.0    3.0   1.0</span>
<span class="sd">1            4            3    2.5    5.0   2.5</span>
<span class="sd">2            2            3    0.0    5.0   5.0</span>
<span class="sd">&gt;&gt;&gt; bin_counts, bins = el.pers.bin(1.0)</span>
<span class="sd">&gt;&gt;&gt; print(bins)</span>
<span class="sd">[-inf   0.   1.   2.   3.   4.   5.  inf]</span>
<span class="sd">&gt;&gt;&gt; print(bin_counts)</span>
<span class="sd">[[ 0.  0.  0.  0.  0.  0.  0.]</span>
<span class="sd"> [ 0.  0.  0.  0.  0.  0.  1.]</span>
<span class="sd"> [ 0.  0.  0.  0.  0.  0.  0.]</span>
<span class="sd"> [ 0.  0.  1.  1.  0.  0.  0.]</span>
<span class="sd"> [ 0.  0.  0.  0.  0.  0.  0.]</span>
<span class="sd"> [ 0.  0.  0.  0.  0.  0.  0.]</span>
<span class="sd"> [ 0.  0.  0.  0.  0.  0.  0.]]</span>
<span class="sd">&gt;&gt;&gt; sorted(list(el.pers.domains.keys()))</span>
<span class="sd">[(0, 1), (2, 3), (3, 4)]</span>
<span class="sd">&gt;&gt;&gt; for interval in el.iter_intervals():</span>
<span class="sd">...     print(&quot;h_A( {} ) == {}&quot;.format(interval,el.interval_height(interval)))</span>
<span class="sd">h_A( (0, 1) ) == 1.0</span>
<span class="sd">h_A( (0, 2) ) == 0.0</span>
<span class="sd">h_A( (0, 3) ) == 0.0</span>
<span class="sd">h_A( (0, 4) ) == 0.0</span>
<span class="sd">h_A( (0, 5) ) == 0.0</span>
<span class="sd">h_A( (1, 2) ) == 0.0</span>
<span class="sd">h_A( (1, 3) ) == 0.0</span>
<span class="sd">h_A( (1, 4) ) == 0.0</span>
<span class="sd">h_A( (1, 5) ) == 0.0</span>
<span class="sd">h_A( (2, 3) ) == 5.0</span>
<span class="sd">h_A( (2, 4) ) == 0.0</span>
<span class="sd">h_A( (2, 5) ) == 0.0</span>
<span class="sd">h_A( (3, 4) ) == 2.5</span>
<span class="sd">h_A( (3, 5) ) == 0.0</span>
<span class="sd">h_A( (4, 5) ) == 0.0</span>
<span class="sd">&gt;&gt;&gt; list(el.pers.forest.keys())</span>
<span class="sd">[None]</span>
<span class="sd">&gt;&gt;&gt; sorted(list(el.pers.forest[None]))</span>
<span class="sd">[0, 1, 2]</span>
<span class="sd">&gt;&gt;&gt; el.jagged(6.0)</span>
<span class="sd">0    0.0</span>
<span class="sd">1    0.0</span>
<span class="sd">2    0.0</span>
<span class="sd">3    0.0</span>
<span class="sd">4    0.0</span>
<span class="sd">5    0.0</span>
<span class="sd">dtype: float64</span>
<span class="sd">&gt;&gt;&gt; el = Signal([6.5,0.0,2.0])</span>
<span class="sd">&gt;&gt;&gt; el.make_pers()</span>
<span class="sd">&gt;&gt;&gt; el.pers.diagram</span>
<span class="sd">   birth_index  death_index  birth  death  pers</span>
<span class="sd">0            1            0    0.0    6.5   6.5</span>
<span class="sd">&gt;&gt;&gt; list(el.pers.forest[None])</span>
<span class="sd">[0]</span>
<span class="sd">&gt;&gt;&gt; el.vertices</span>
<span class="sd">   time  height</span>
<span class="sd">0   0.0     6.5</span>
<span class="sd">1   1.0     0.0</span>
<span class="sd">2   2.0     2.0</span>
<span class="sd">&gt;&gt;&gt; el.jagged() #el.pers.diagram,el.vertices.index,el.vertices.dtype)</span>
<span class="sd">0    6.5</span>
<span class="sd">1    0.0</span>
<span class="sd">2    0.0</span>
<span class="sd">dtype: float64</span>
<span class="sd">&gt;&gt;&gt; elN = el.sample_near(sigma=0.1)</span>
<span class="sd">&gt;&gt;&gt; elN.make_pers()</span>
<span class="sd">&gt;&gt;&gt; elN.pers.domains == el.pers.domains</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; el = Signal([6.5,7.0,2.0,4.5,3.9,9.0,8.3,8.7,5.5,9.9])</span>
<span class="sd">&gt;&gt;&gt; el.vertices</span>
<span class="sd">   time  height</span>
<span class="sd">0   0.0     6.5</span>
<span class="sd">1   1.0     7.0</span>
<span class="sd">2   2.0     2.0</span>
<span class="sd">3   3.0     4.5</span>
<span class="sd">4   4.0     3.9</span>
<span class="sd">5   5.0     9.0</span>
<span class="sd">6   6.0     8.3</span>
<span class="sd">7   7.0     8.7</span>
<span class="sd">8   8.0     5.5</span>
<span class="sd">9   9.0     9.9</span>
<span class="sd">&gt;&gt;&gt; el.edges</span>
<span class="sd">   src  dst  max  height</span>
<span class="sd">2    2    3    3     4.5</span>
<span class="sd">3    3    4    3     4.5</span>
<span class="sd">0    0    1    1     7.0</span>
<span class="sd">1    1    2    1     7.0</span>
<span class="sd">6    6    7    7     8.7</span>
<span class="sd">7    7    8    7     8.7</span>
<span class="sd">4    4    5    5     9.0</span>
<span class="sd">5    5    6    5     9.0</span>
<span class="sd">8    8    9    9     9.9</span>
<span class="sd">&gt;&gt;&gt; el.make_pers()</span>
<span class="sd">&gt;&gt;&gt; el.pers.diagram</span>
<span class="sd">   birth_index  death_index  birth  death  pers</span>
<span class="sd">2            6            7    8.3    8.7   0.4</span>
<span class="sd">1            0            1    6.5    7.0   0.5</span>
<span class="sd">0            4            3    3.9    4.5   0.6</span>
<span class="sd">3            8            5    5.5    9.0   3.5</span>
<span class="sd">4            2            9    2.0    9.9   7.9</span>
<span class="sd">&gt;&gt;&gt; el.feature()</span>
<span class="sd">   time  height</span>
<span class="sd">2   2.0     2.0</span>
<span class="sd">3   3.0     4.5</span>
<span class="sd">4   4.0     3.9</span>
<span class="sd">5   5.0     9.0</span>
<span class="sd">6   6.0     8.3</span>
<span class="sd">7   7.0     8.7</span>
<span class="sd">8   8.0     5.5</span>
<span class="sd">9   9.0     9.9</span>
<span class="sd">&gt;&gt;&gt; el.pers.syzygy((0,0))</span>
<span class="sd">2    0.4</span>
<span class="sd">1    0.5</span>
<span class="sd">0    0.6</span>
<span class="sd">3    3.5</span>
<span class="sd">4    7.9</span>
<span class="sd">dtype: float64</span>
<span class="sd">&gt;&gt;&gt; el.pers.syzygy((1,2))</span>
<span class="sd">2     251.2908</span>
<span class="sd">1     159.2500</span>
<span class="sd">0      47.3850</span>
<span class="sd">3    1559.2500</span>
<span class="sd">4    1548.5580</span>
<span class="sd">dtype: float64</span>
<span class="sd">&gt;&gt;&gt; el.pers.forest_parents == {0: 4, 1: None, 2: 3, 3: 4, 4: None}</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; el.vertices[&#39;height&#39;].sum()/len(el.vertices)</span>
<span class="sd">6.5299999999999994</span>
<span class="sd">&gt;&gt;&gt; el.normalize()</span>
<span class="sd">&gt;&gt;&gt; el2 = Signal(el.vertices)</span>
<span class="sd">&gt;&gt;&gt; el2.make_pers()</span>
<span class="sd">&gt;&gt;&gt; all(el2.pers.diagram == el.pers.diagram)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; el = Signal([0.0,3.0,1.5,2.2,0.001])</span>
<span class="sd">&gt;&gt;&gt; el.make_pers()</span>
<span class="sd">&gt;&gt;&gt; el.vertices</span>
<span class="sd">   time  height</span>
<span class="sd">0   0.0   0.000</span>
<span class="sd">1   1.0   3.000</span>
<span class="sd">2   2.0   1.500</span>
<span class="sd">3   3.0   2.200</span>
<span class="sd">4   4.0   0.001</span>
<span class="sd">&gt;&gt;&gt; el.edges</span>
<span class="sd">   src  dst  max  height</span>
<span class="sd">2    2    3    3     2.2</span>
<span class="sd">3    3    4    3     2.2</span>
<span class="sd">0    0    1    1     3.0</span>
<span class="sd">1    1    2    1     3.0</span>
<span class="sd">&gt;&gt;&gt; el.pers.diagram</span>
<span class="sd">   birth_index  death_index  birth  death   pers</span>
<span class="sd">0            2            3  1.500    2.2  0.700</span>
<span class="sd">1            4            1  0.001    3.0  2.999</span>
<span class="sd">2            0            1  0.000    3.0  3.000</span>
<span class="sd">&gt;&gt;&gt; el = Signal([0.0,0.7,0.45,0.55,0.3, 1.0],</span>
<span class="sd">...             times=[0.1, 0.2, 0.3, 0.6, 0.8, 0.85])</span>
<span class="sd">&gt;&gt;&gt; el.vertices</span>
<span class="sd">   time  height</span>
<span class="sd">0  0.10    0.00</span>
<span class="sd">1  0.20    0.70</span>
<span class="sd">2  0.30    0.45</span>
<span class="sd">3  0.60    0.55</span>
<span class="sd">4  0.80    0.30</span>
<span class="sd">5  0.85    1.00</span>
<span class="sd">&gt;&gt;&gt; el.edges</span>
<span class="sd">   src  dst  max  height</span>
<span class="sd">2    2    3    3    0.55</span>
<span class="sd">3    3    4    3    0.55</span>
<span class="sd">0    0    1    1    0.70</span>
<span class="sd">1    1    2    1    0.70</span>
<span class="sd">4    4    5    5    1.00</span>
<span class="sd">&gt;&gt;&gt; el.make_pers()</span>
<span class="sd">&gt;&gt;&gt; el.pers.diagram</span>
<span class="sd">   birth_index  death_index  birth  death  pers</span>
<span class="sd">0            2            3   0.45   0.55   0.1</span>
<span class="sd">1            4            1   0.30   0.70   0.4</span>
<span class="sd">2            0            5   0.00   1.00   1.0</span>
<span class="sd">&gt;&gt;&gt; el = Signal([0.0,0.5,0.4,0.9,0.1,1.0])</span>
<span class="sd">&gt;&gt;&gt; el.make_pers()</span>
<span class="sd">&gt;&gt;&gt; el.pers.diagram</span>
<span class="sd">   birth_index  death_index  birth  death  pers</span>
<span class="sd">0            2            1    0.4    0.5   0.1</span>
<span class="sd">1            4            3    0.1    0.9   0.8</span>
<span class="sd">2            0            5    0.0    1.0   1.0</span>
<span class="sd">&gt;&gt;&gt; for F in el.iter_features(min_pers=0.5): print(F)</span>
<span class="sd">   time  height</span>
<span class="sd">0   0.0     0.0</span>
<span class="sd">1   1.0     0.5</span>
<span class="sd">2   2.0     0.4</span>
<span class="sd">3   3.0     0.9</span>
<span class="sd">4   4.0     0.1</span>
<span class="sd">5   5.0     1.0</span>
<span class="sd">   time  height</span>
<span class="sd">3   3.0     0.9</span>
<span class="sd">4   4.0     0.1</span>
<span class="sd">&gt;&gt;&gt; el = Signal(np.sin(np.arange(0,8*np.pi,0.1)))</span>
<span class="sd">&gt;&gt;&gt; el.make_pers()</span>
<span class="sd">&gt;&gt;&gt; el.pers.domains == {(110, 204): 4, (204, 236): 3, (0, 16): 2, (47, 79): 0, (141, 173): 1}</span>
<span class="sd">True</span>


<span class="sd">&gt;&gt;&gt; s = Signal([50.0, 120.0, 100, 180, 200, 150, 135])</span>
<span class="sd">&gt;&gt;&gt; s.make_pers()</span>
<span class="sd">&gt;&gt;&gt; s.pers.diagram</span>
<span class="sd">   birth_index  death_index  birth  death   pers</span>
<span class="sd">0            2            1  100.0  120.0   20.0</span>
<span class="sd">1            6            4  135.0  200.0   65.0</span>
<span class="sd">2            0            4   50.0  200.0  150.0</span>
<span class="sd">&gt;&gt;&gt; s.pers.mergetree</span>
<span class="sd">{1: (0, 2), 4: (1, 6)}</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span><span class="o">,</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">scipy.spatial.distance</span> <span class="k">as</span> <span class="nn">ssd</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">fast_algorithms</span><span class="p">,</span> <span class="n">curve_geometry</span>
<span class="kn">import</span> <span class="nn">homology.dim0</span>


<div class="viewcode-block" id="jagged"><a class="viewcode-back" href="../generated/timeseries.jagged.html#timeseries.jagged">[docs]</a><span class="k">def</span> <span class="nf">jagged</span><span class="p">(</span><span class="n">persdiag</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Produce a piecewise-linear function that matches the given persistence</span>
<span class="sd">    diagram. This assumes that the index for the vertices is sequential and</span>
<span class="sd">    linear, so that the mergetree can be ignored.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    persdiag : :class:`homology.PersDiag`</span>
<span class="sd">        A 0-dimensional persistence diagram</span>
<span class="sd">    index : list-like</span>
<span class="sd">        The domain index for the function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    function : `pandas.Series`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`timeseries.Signal.jagged` :func:`timeseries.Signal.makepers`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">persdiag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">V</span><span class="p">[</span><span class="n">persdiag</span><span class="p">[</span><span class="s1">&#39;birth_index&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">persdiag</span><span class="p">[</span><span class="s1">&#39;birth&#39;</span><span class="p">]</span>
    <span class="n">V</span><span class="p">[</span><span class="n">persdiag</span><span class="p">[</span><span class="s1">&#39;death_index&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">persdiag</span><span class="p">[</span><span class="s1">&#39;death&#39;</span><span class="p">]</span>
    <span class="c1"># fill with linear interpolation</span>
    <span class="n">V</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
    <span class="c1"># make sure we don&#39;t lose domain</span>
    <span class="n">V</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># the end</span>
    <span class="n">V</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfill&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># the beginning</span>
    <span class="c1"># MUST ADD CIRCULAR INTERPOLATION!</span>
    <span class="k">return</span> <span class="n">V</span></div>

<span class="k">def</span> <span class="nf">wavy</span><span class="p">(</span><span class="n">pasrdiad</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Produce a piecewise-sine function that matches the given persistence</span>
<span class="sd">    diagram. This assumes that the index for the vertices is sequential and</span>
<span class="sd">    linear, so that the mergetree can be ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    persdiag : :class:`homology.PersDiag`</span>
<span class="sd">        A 0-dimensional persistence diagram</span>
<span class="sd">    index : list-like</span>
<span class="sd">        The domain index for the function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    function : `pandas.Series`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`timeseries.Signal.jagged` :func:`timeseries.Signal.makepers`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#V = pd.Series(index=index, dtype=np.float64)</span>
    <span class="c1">#if len(persdiag) == 0:</span>
    <span class="c1">#    V[:] = 0</span>
    <span class="c1">#V[persdiag[&#39;birth_index&#39;]] = persdiag[&#39;birth&#39;]</span>
    <span class="c1">#V[persdiag[&#39;death_index&#39;]] = persdiag[&#39;death&#39;]</span>
    <span class="c1">## fill with linear interpolation</span>
    <span class="c1">#V.interpolate(method=&#39;linear&#39;, inplace=True) </span>
    <span class="c1">## make sure we don&#39;t lose domain</span>
    <span class="c1">#V.fillna(method=&#39;ffill&#39;, inplace=True)  # the end</span>
    <span class="c1">#V.fillna(method=&#39;bfill&#39;, inplace=True)  # the beginning</span>
    <span class="c1"># MUST ADD CIRCULAR INTERPOLATION!</span>
    <span class="c1">#return V</span>

<div class="viewcode-block" id="Signal"><a class="viewcode-back" href="../generated/timeseries.Signal.html#timeseries.Signal">[docs]</a><span class="k">class</span> <span class="nc">Signal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; produce an Signal from function output values.  function input</span>
<span class="sd">        domain is implicitly range(len(values)).  The resulting Signal has</span>
<span class="sd">        vertices with function values and edges with max of adjacent pairs.</span>
<span class="sd">            A Signal is a pair of pd DataFrames that act as indexed</span>
<span class="sd">        lists of numerical values.  The vertices are stored as a pd Series,</span>
<span class="sd">        Signal.index provides the vertex indices.</span>
<span class="sd">            The edges are a DataFrame, giving triples labeled by</span>
<span class="sd">        (&#39;src&#39;, &#39;dst&#39;, &#39;max&#39;, &#39;height&#39;), where src and dst are the *indices* (not</span>
<span class="sd">        the *values*) of vertices.  Vertices should be considered fixed on</span>
<span class="sd">        initialization.  Overloaded functions refer to edges, not vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">values</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">columns</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">values</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
            <span class="k">assert</span> <span class="n">values</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
 
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        
            <span class="n">N</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">times</span><span class="p">,</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">values</span><span class="p">},</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">],</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># if times is not None:</span>
        <span class="c1">#     self.times</span>
        <span class="c1">#</span>
        <span class="c1"># if type(values) == pd.core.series.Series and values.index.dtype == &#39;int64&#39;:</span>
        <span class="c1">#     self.vertices = values.copy()</span>
        <span class="c1"># else:</span>
        <span class="c1">#     self.vertices = pd.Series(values, dtype=np.float64,</span>
        <span class="c1">#         index=np.arange(len(values), dtype=np.int64))</span>

        <span class="c1"># figure out whether the value is from the left (0) or right (1)</span>
        <span class="c1"># this is now done in homology.dim0.unionfind.</span>
        <span class="n">leftright</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">maxes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">leftright</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;src&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;dst&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">maxes</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">maxes</span><span class="p">]},</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">,</span> <span class="s1">&#39;dst&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="s1">&#39;src&#39;</span><span class="p">],</span>
                               <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
                               <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                  <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># assert pos.size == len(self.edges.index)</span>
        <span class="c1"># self.edges[&#39;pos&#39;] = pos</span>

<div class="viewcode-block" id="Signal.make_pers"><a class="viewcode-back" href="../generated/timeseries.Signal.make_pers.html#timeseries.Signal.make_pers">[docs]</a>    <span class="k">def</span> <span class="nf">make_pers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tbirth_index</span><span class="p">,</span> <span class="n">tdeath_index</span><span class="p">,</span> <span class="n">ybirth_index</span><span class="p">,</span> <span class="n">ydeath_index</span><span class="p">,</span> <span class="n">mergetree</span> <span class="o">=</span> <span class="n">homology</span><span class="o">.</span><span class="n">dim0</span><span class="o">.</span><span class="n">unionfind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pers</span> <span class="o">=</span> <span class="n">homology</span><span class="o">.</span><span class="n">PersDiag</span><span class="p">(</span><span class="n">tbirth_index</span><span class="p">,</span> <span class="n">tdeath_index</span><span class="p">,</span> <span class="n">ybirth_index</span><span class="p">,</span> <span class="n">ydeath_index</span><span class="p">,</span> <span class="n">mergetree</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

<div class="viewcode-block" id="Signal.gap"><a class="viewcode-back" href="../generated/timeseries.Signal.gap.html#timeseries.Signal.gap">[docs]</a>    <span class="k">def</span> <span class="nf">gap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the largest homology. &quot;&quot;&quot;</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">diagram</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># sorted by length!</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">bc</span></div>

<div class="viewcode-block" id="Signal.iter_intervals"><a class="viewcode-back" href="../generated/timeseries.Signal.iter_intervals.html#timeseries.Signal.iter_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">iter_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the itertools combinations iterator over all sub-intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal.interval_height"><a class="viewcode-back" href="../generated/timeseries.Signal.interval_height.html#timeseries.Signal.interval_height">[docs]</a>    <span class="k">def</span> <span class="nf">interval_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; the indicator-persistence function for intervals,</span>
<span class="sd">        called h_U(A) in the notes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">domains</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">diagram</span><span class="p">[</span><span class="s1">&#39;pers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="Signal.sample_near"><a class="viewcode-back" href="../generated/timeseries.Signal.sample_near.html#timeseries.Signal.sample_near">[docs]</a>    <span class="k">def</span> <span class="nf">sample_near</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return a Signal object that is L2-near self in the normal</span>
<span class="sd">        distribution. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="n">sigma</span><span class="o">*</span><span class="n">diff</span><span class="p">)</span> </div>

<div class="viewcode-block" id="Signal.height_measure"><a class="viewcode-back" href="../generated/timeseries.Signal.height_measure.html#timeseries.Signal.height_measure">[docs]</a>    <span class="k">def</span> <span class="nf">height_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_pers</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Use a simulation to estimate the height-measure of an interval. &quot;&quot;&quot;</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="k">import</span> <span class="n">ProcessPoolExecutor</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> 
            <span class="n">all_heights</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">fast_algorithms</span><span class="o">.</span><span class="n">sample_height</span><span class="p">,</span> <span class="n">all_data</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_heights</span> <span class="o">=</span> <span class="p">[</span><span class="n">fast_algorithms</span><span class="o">.</span><span class="n">sample_height</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_data</span><span class="p">]</span>
        <span class="n">all_heights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">all_heights</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_pers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">all_heights</span><span class="p">[</span><span class="n">all_heights</span> <span class="o">&lt;</span> <span class="n">min_pers</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tot_heights</span> <span class="o">=</span> <span class="n">all_heights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">num_samples</span>
        <span class="n">measures</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">U</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">tot_heights</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">U</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">length</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">:</span>
                <span class="n">measures</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">measures</span><span class="p">[</span><span class="n">length</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tot_heights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">measures</span></div>

<div class="viewcode-block" id="Signal.feature"><a class="viewcode-back" href="../generated/timeseries.Signal.feature.html#timeseries.Signal.feature">[docs]</a>    <span class="k">def</span> <span class="nf">feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the region of a feature, with vertical displacement threshold tau. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">lefts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">rights</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">V</span></div>

<div class="viewcode-block" id="Signal.iter_features"><a class="viewcode-back" href="../generated/timeseries.Signal.iter_features.html#timeseries.Signal.iter_features">[docs]</a>    <span class="k">def</span> <span class="nf">iter_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_pers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth_first</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; walk the feature tree. &quot;&quot;&quot;</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">diagram</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">forest</span>
        <span class="n">to_walk</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="kc">None</span><span class="p">])</span>  <span class="c1"># start at root of tree</span>
        <span class="k">while</span> <span class="n">to_walk</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">to_walk</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">bc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;pers&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">min_pers</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">depth_first</span><span class="p">:</span>
                <span class="n">to_walk</span><span class="o">.</span><span class="n">extendleft</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_walk</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span></div>

<div class="viewcode-block" id="Signal.feature_match"><a class="viewcode-back" href="../generated/timeseries.Signal.feature_match.html#timeseries.Signal.feature_match">[docs]</a>    <span class="k">def</span> <span class="nf">feature_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="n">total_match</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_intervals</span><span class="p">():</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">match_number</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">interval_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_measure</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span>
                                                  <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
                                                  <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
            <span class="n">total_match</span> <span class="o">+=</span> <span class="n">match_number</span> <span class="o">*</span> <span class="n">interval_height</span>

        <span class="k">return</span> <span class="n">total_match</span></div>

<div class="viewcode-block" id="Signal.jagged"><a class="viewcode-back" href="../generated/timeseries.Signal.jagged.html#timeseries.Signal.jagged">[docs]</a>    <span class="k">def</span> <span class="nf">jagged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; call :func:`timeseries.jagged` on this :class:`Signal`&#39;s </span>
<span class="sd">        own persistence diagram. This effectively makes a piecewise-linear</span>
<span class="sd">        version of the same function, with the same extrema. &quot;&quot;&quot;</span>
        <span class="c1"># simple cache</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_jagged</span>
            <span class="k">if</span> <span class="n">beta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jagged</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jagged</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jagged</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="n">keepbc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">beta</span><span class="p">)[</span><span class="s1">&#39;keepcode&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jagged</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span> <span class="o">=</span> <span class="n">jagged</span><span class="p">(</span><span class="n">keepbc</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jagged</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span></div>

<div class="viewcode-block" id="Signal.smoothen"><a class="viewcode-back" href="../generated/timeseries.Signal.smoothen.html#timeseries.Signal.smoothen">[docs]</a>    <span class="k">def</span> <span class="nf">smoothen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">beta</span><span class="p">)[</span><span class="s1">&#39;keepcode&#39;</span><span class="p">]</span>
        <span class="n">cut_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pd</span><span class="p">[[</span><span class="s1">&#39;birth_index&#39;</span><span class="p">,</span> <span class="s1">&#39;death_index&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                      <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)])</span>
        <span class="n">cut_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cut_indices</span><span class="p">)</span>

        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
    
        <span class="k">for</span> <span class="n">j0</span><span class="p">,</span><span class="n">j1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cut_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cut_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>        
            <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">F</span><span class="p">[</span><span class="n">j0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">F</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">F</span><span class="p">[</span><span class="n">j0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">F</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]))</span>
            <span class="c1">#else:</span>
            <span class="c1">#    assert F[j0:j1].min() == F[j0:j1].max()</span>
    
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">times</span> <span class="o">==</span> <span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Signal</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span></div>


<div class="viewcode-block" id="Signal.profile"><a class="viewcode-back" href="../generated/timeseries.Signal.profile.html#timeseries.Signal.profile">[docs]</a>    <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arch</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; produce profile by dragging an archetype across self, </span>
<span class="sd">        looking for matches.  You may want to normalize arch first. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arch</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">,</span> <span class="s2">&quot;Archetype is too long.&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
<span class="c1">#        if normalize: arch = (arch-arch.mean())/(arch.max() - arch.min())</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">snip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">snip</span> <span class="o">=</span> <span class="p">(</span><span class="n">snip</span><span class="o">-</span><span class="n">snip</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="n">snip</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">snip</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">arch</span> <span class="o">-</span> <span class="n">snip</span><span class="p">))</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp2</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">p</span></div>
        <span class="c1"># if len(p) &gt; 1:</span>
        <span class="c1">#    P = Signal(p)</span>
        <span class="c1"># return P</span>

<div class="viewcode-block" id="Signal.iter_windows_by_index"><a class="viewcode-back" href="../generated/timeseries.Signal.iter_windows_by_index.html#timeseries.Signal.iter_windows_by_index">[docs]</a>    <span class="k">def</span> <span class="nf">iter_windows_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Produce equal-length Signals using a sliding-window on self.  This</span>
<span class="sd">        slides by index, not by abstract time. </span>
<span class="sd">        window = length of window (number of indices) </span>
<span class="sd">        time_step  = step size in index.  (default = 1)</span>
<span class="sd">        time_start = start index (default = None, min index)</span>
<span class="sd">        time_stop  = stop index  (default = None, max index)</span>
<span class="sd">        normalize = renormalize by N(0,1) on window? (default = False)</span>
<span class="sd">        norm = norm function to use for comparison (default = np.linalg.norm)</span>


<span class="sd">        return: iterator of np arrays, whose columns are timestamp, value.</span>
<span class="sd">        To access the tracks as a list,use</span>
<span class="sd">        list(Signal.iter_windows_index())</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; S = Signal([2.0,3.0,0.0,5.0,2.5,2.9])</span>
<span class="sd">        &gt;&gt;&gt; for s in S.iter_windows_by_index(4, step=2):</span>
<span class="sd">        ...     print(s[:,1])</span>
<span class="sd">        [ 2.  3.  0.  5.]</span>
<span class="sd">        [ 0.   5.   2.5  2.9]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">start_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
            <span class="n">stop_i</span> <span class="o">=</span> <span class="n">start_i</span> <span class="o">+</span> <span class="n">window</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">start_i</span><span class="p">:</span><span class="n">stop_i</span><span class="p">,</span> <span class="p">:]</span>

            <span class="k">if</span> <span class="n">stop_i</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
                <span class="k">break</span></div>
 
<div class="viewcode-block" id="Signal.self_similarity"><a class="viewcode-back" href="../generated/timeseries.Signal.self_similarity.html#timeseries.Signal.self_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">self_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                        <span class="n">dist</span><span class="o">=</span><span class="n">ssd</span><span class="o">.</span><span class="n">euclidean</span><span class="p">,</span> <span class="n">normalizer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compare sliding windows of this Signal using a distance function. </span>
<span class="sd">       </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        window  (length of segment)</span>
<span class="sd">        step    (steps to move between windows)</span>
<span class="sd">        start   (index to start at)</span>
<span class="sd">        stop    (index to stop at)</span>
<span class="sd">        dist    (distance function to use. Default:`scipy.spatial.distance.euclidean`</span>
<span class="sd">        normalizer (function to use to renormalize each window.  default:None)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        an iterator of the window comparisons.</span>
<span class="sd">        (0,0), (0,1), (0,2), ... (0, n-1), (1,1), (1,2), ...  (n-2, n-1)</span>
<span class="sd">        </span>
<span class="sd">        The return elements are pairs ((index_lo, index_hi), norm), which </span>
<span class="sd">        can be used to populate a dictionary or array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; S = Signal([0.0, 0.0, 3.0, 4.0, 6.0, 8.0])</span>
<span class="sd">        &gt;&gt;&gt; Sss = list(S.self_similarity(window=2, step=2))</span>
<span class="sd">        &gt;&gt;&gt; for (ij, d) in Sss:</span>
<span class="sd">        ...     print(&quot;{} -&gt; {}&quot;.format(ij,d))</span>
<span class="sd">        (0, 0) -&gt; 0.0</span>
<span class="sd">        (0, 2) -&gt; 5.0</span>
<span class="sd">        (0, 4) -&gt; 10.0</span>
<span class="sd">        (2, 2) -&gt; 0.0</span>
<span class="sd">        (2, 4) -&gt; 5.0</span>
<span class="sd">        (4, 4) -&gt; 0.0</span>
<span class="sd">        &gt;&gt;&gt; D = np.array([d for ij,d in Sss])</span>
<span class="sd">        &gt;&gt;&gt; print(D)</span>
<span class="sd">        [  0.   5.  10.   0.   5.   0.]</span>
<span class="sd">        &gt;&gt;&gt; print(ssd.squareform(D)) # scipy.spatial.distance</span>
<span class="sd">        [[  0.   0.   5.  10.]</span>
<span class="sd">         [  0.   0.   0.   5.]</span>
<span class="sd">         [  5.   0.   0.   0.]</span>
<span class="sd">         [ 10.   5.   0.   0.]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">start_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
            <span class="n">stop_i</span> <span class="o">=</span> <span class="n">start_i</span> <span class="o">+</span> <span class="n">window</span>
            <span class="n">win_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">start_i</span><span class="p">:</span><span class="n">stop_i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">win_i</span> <span class="o">=</span> <span class="n">normalizer</span><span class="p">(</span><span class="n">win_i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">start_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">[</span><span class="n">i</span><span class="p">:]):</span>
                <span class="n">stop_j</span> <span class="o">=</span> <span class="n">start_j</span> <span class="o">+</span> <span class="n">window</span>
                <span class="n">win_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">start_j</span><span class="p">:</span><span class="n">stop_j</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">win_j</span> <span class="o">=</span> <span class="n">normalizer</span><span class="p">(</span><span class="n">win_j</span><span class="p">)</span>
                <span class="k">yield</span> <span class="p">((</span><span class="n">start_i</span><span class="p">,</span> <span class="n">start_j</span><span class="p">),</span> <span class="n">dist</span><span class="p">(</span><span class="n">win_i</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">win_j</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">stop_i</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
                <span class="k">break</span></div>
 
<span class="c1">#</span>
<div class="viewcode-block" id="Signal.plot"><a class="viewcode-back" href="../generated/timeseries.Signal.plot.html#timeseries.Signal.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Signal&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Plot the Signal.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        canvas : class:`bokeh.plotting.figure.Figure` or :class:`matplotlib.axes._subplots.AxesSubplot`</span>
<span class="sd">                A bokeh or pyplot canvas to draw on.  Create one with</span>
<span class="sd">                :code:`canvas = bokeh.plotting.figure()` or</span>
<span class="sd">                :code:`fig,canvas = matplotlib.pyplot.subplots()`</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        You have to save or show axes after running this call.</span>

<span class="sd">        &quot;&quot;&quot;</span>
 
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">canvas</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;bokeh.plotting.figure&#39;</span><span class="p">:</span>
            <span class="n">canvas_type</span> <span class="o">=</span> <span class="s2">&quot;bokeh&quot;</span>
            <span class="kn">import</span> <span class="nn">bokeh.plotting</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">canvas</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;matplotlib.axes._subplots&#39;</span><span class="p">:</span>
            <span class="n">canvas_type</span> <span class="o">=</span> <span class="s2">&quot;pyplot&quot;</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;canvas must be a bokeh.plotting.figure() or a matplotlib.pyplot.subplots()[1].  You gave me </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">canvas</span><span class="p">))</span>
                <span class="p">)</span> 
        <span class="k">if</span> <span class="n">canvas_type</span> <span class="o">==</span> <span class="s2">&quot;bokeh&quot;</span><span class="p">:</span>
            <span class="n">canvas</span><span class="o">.</span><span class="n">title</span><span class="o">=</span><span class="n">title</span>
        <span class="k">elif</span> <span class="n">canvas_type</span> <span class="o">==</span> <span class="s2">&quot;pyplot&quot;</span><span class="p">:</span>
            <span class="n">canvas</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">canvas_type</span> <span class="o">==</span> <span class="s2">&quot;bokeh&quot;</span><span class="p">:</span>
            <span class="n">canvas</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">canvas</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">canvas_type</span> <span class="o">==</span> <span class="s2">&quot;pyplot&quot;</span><span class="p">:</span>
            <span class="n">canvas</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">canvas</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Signal.from_pointcloud"><a class="viewcode-back" href="../generated/timeseries.Signal.from_pointcloud.html#timeseries.Signal.from_pointcloud">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pointcloud</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">direction</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">direction</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal.normalize"><a class="viewcode-back" href="../generated/timeseries.Signal.normalize.html#timeseries.Signal.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; change this Signal object to have mean = 0 and max-min = 1 &quot;&quot;&quot;</span>
        <span class="n">bc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">diagram</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">()[</span><span class="s1">&#39;pers&#39;</span><span class="p">]</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span><span class="o">/</span><span class="n">h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span><span class="o">/</span><span class="n">h</span>
        <span class="n">bc</span><span class="p">[</span><span class="s1">&#39;birth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bc</span><span class="p">[</span><span class="s1">&#39;birth&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span><span class="o">/</span><span class="n">h</span>
        <span class="n">bc</span><span class="p">[</span><span class="s1">&#39;death&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bc</span><span class="p">[</span><span class="s1">&#39;death&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span><span class="o">/</span><span class="n">h</span>
        <span class="n">bc</span><span class="p">[</span><span class="s1">&#39;pers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bc</span><span class="p">[</span><span class="s1">&#39;pers&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">h</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="SpaceCurve"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.html#timeseries.SpaceCurve">[docs]</a><span class="k">class</span> <span class="nc">SpaceCurve</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; SpaceCurve is a Python class for studying curves in </span>
<span class="sd">    :math:`\mathbb{R}^2` or :math:`\mathbb{R}^3`.</span>
<span class="sd">    For example, a SpaceCurve could represent kinematic flight data, or</span>
<span class="sd">    trajectories of vehicles given by GPS coordinates.</span>
<span class="sd">    </span>
<span class="sd">    All arguments other than :code:`tn` are optional.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tn : list-like</span>
<span class="sd">        Integer timestamps, typically in &#39;numpy.int64` nanoseconds-since-epoch</span>
<span class="sd">    px : list-like</span>
<span class="sd">    py : list-like</span>
<span class="sd">    pz : list-like</span>
<span class="sd">        Positions in :class:`numpy.float64` meters</span>
<span class="sd">    quality : list-like</span>
<span class="sd">        Quality/accuracy of a particular location</span>
<span class="sd">    trackid : int</span>
<span class="sd">        An integer label for the track</span>
<span class="sd">    platform : str</span>
<span class="sd">        A descriptive label</span>
<span class="sd">    activity : str</span>
<span class="sd">        A descriptive label</span>
<span class="sd">    mollified: bool</span>
<span class="sd">        Whether this track has undegone mollification, for example with :func:`clean_copy`</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    data : :class:`pandas.DataFrame`</span>
<span class="sd">        The original position and velocity data, as originally provided.</span>
<span class="sd">        The index of this DataFrame is the :code:`tn` integer time index.</span>

<span class="sd">    info : :class:`pandas.DataFrame`</span>
<span class="sd">        Data computed using various algorithms.  This is filled by </span>
<span class="sd">        :func:`compute`, but more can be added.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">px</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">py</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1">#             vx=None, vy=None, vz=None,</span>
                 <span class="n">quality</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">trackid</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">activity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mollified</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">tn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>\
            <span class="s2">&quot;A SpaceCurve cannot have empty nanosecond index. You gave me </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span> 

        <span class="k">if</span> <span class="n">px</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tn</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">py</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">py</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tn</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tn</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1">#if vx is None:</span>
        <span class="c1">#    vx = np.zeros(tn.shape, dtype=np.float64)</span>
        <span class="c1">#if vy is None:</span>
        <span class="c1">#    vy = np.zeros(tn.shape, dtype=np.float64)</span>
        <span class="c1">#if vz is None:</span>
        <span class="c1">#    vz = np.zeros(tn.shape, dtype=np.float64)</span>
        <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">quality</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">tn</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">py</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">pz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1">#vx = np.array(vx, dtype=np.float64)</span>
        <span class="c1">#vy = np.array(vy, dtype=np.float64)</span>
        <span class="c1">#vz = np.array(vz, dtype=np.float64)</span>
        <span class="n">quality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">px</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">py</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pz</span><span class="p">)</span>
        <span class="c1">#assert len(tn) == len(vx)</span>
        <span class="c1">#assert len(tn) == len(vy)</span>
        <span class="c1">#assert len(tn) == len(vz)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">quality</span><span class="p">)</span>

        <span class="n">sort_by_time</span> <span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        
        <span class="n">tn</span> <span class="o">=</span> <span class="n">tn</span><span class="p">[</span><span class="n">sort_by_time</span><span class="p">]</span>
        <span class="n">px</span> <span class="o">=</span> <span class="n">px</span><span class="p">[</span><span class="n">sort_by_time</span><span class="p">]</span>
        <span class="n">py</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">sort_by_time</span><span class="p">]</span>
        <span class="n">pz</span> <span class="o">=</span> <span class="n">pz</span><span class="p">[</span><span class="n">sort_by_time</span><span class="p">]</span>
        <span class="c1">#vx = vx[sort_by_time]</span>
        <span class="c1">#vy = vy[sort_by_time]</span>
        <span class="c1">#vz = vz[sort_by_time]</span>
        <span class="n">quality</span> <span class="o">=</span> <span class="n">quality</span><span class="p">[</span><span class="n">sort_by_time</span><span class="p">]</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="p">(</span><span class="n">tn</span> <span class="o">-</span> <span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">ts</span><span class="p">,</span>
                                  <span class="s1">&#39;pos_x&#39;</span><span class="p">:</span> <span class="n">px</span><span class="p">,</span>
                                  <span class="s1">&#39;pos_y&#39;</span><span class="p">:</span> <span class="n">py</span><span class="p">,</span>
                                  <span class="s1">&#39;pos_z&#39;</span><span class="p">:</span> <span class="n">pz</span><span class="p">,</span>
                                  <span class="c1">#&#39;vel_x&#39;: vx,</span>
                                  <span class="c1">#&#39;vel_y&#39;: vy,</span>
                                  <span class="c1">#&#39;vel_z&#39;: vz,</span>
                                  <span class="s1">&#39;quality&#39;</span><span class="p">:</span> <span class="n">quality</span><span class="p">},</span>
                                 <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_x&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_y&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_z&#39;</span><span class="p">,</span> 
                                                  <span class="c1">#&#39;vel_x&#39;, &#39;vel_y&#39;, &#39;vel_z&#39;,</span>
                                                  <span class="s1">&#39;quality&#39;</span><span class="p">],</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">tn</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({},</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trackid</span> <span class="o">=</span> <span class="n">trackid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">platform</span> <span class="o">=</span> <span class="n">platform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activity</span> <span class="o">=</span> <span class="n">activity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mollified</span> <span class="o">=</span> <span class="n">mollified</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get raw data via index &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
    
<div class="viewcode-block" id="SpaceCurve.accel"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.accel.html#timeseries.SpaceCurve.accel">[docs]</a>    <span class="k">def</span> <span class="nf">accel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Change time parametrization, to represent a constant tangential </span>
<span class="sd">        acceleration (or deceleration).  Locations, initial time, and</span>
<span class="sd">        arc-length are preserved.</span>
<span class="sd">        </span>
<span class="sd">        The first timestep is changed to have (1-rate) times the speed of the</span>
<span class="sd">        original&#39;s first timestep.  The last timestep is changed to have</span>
<span class="sd">        (1+rate) times the speed of the original&#39;s last timestep.  </span>
<span class="sd">        That is, if S is a `SpaceCurve` of constant speed, then S.accel(-0.1)</span>
<span class="sd">        will start 10% faster and end 10% slower than S. </span>


<span class="sd">        If speed[i] changes to speed[i]*q[i], then delta_t[i] changes to </span>
<span class="sd">        delta_t[i]*p[i], where p[i] = 1 / q[i]</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tn = np.arange(0, 5*1e9, 1e9)</span>
<span class="sd">        &gt;&gt;&gt; s = SpaceCurve(tn=tn, px=10.0*tn/1e9) # drive straight at 10m/s</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        SpaceCurve with 5 entries and duration 4.000000000</span>
<span class="sd">        &gt;&gt;&gt; s.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0    0.0    0.0    0.0       -1</span>
<span class="sd">        1000000000   1.0   10.0    0.0    0.0       -1</span>
<span class="sd">        2000000000   2.0   20.0    0.0    0.0       -1</span>
<span class="sd">        3000000000   3.0   30.0    0.0    0.0       -1</span>
<span class="sd">        4000000000   4.0   40.0    0.0    0.0       -1</span>
<span class="sd">        &gt;&gt;&gt; s.compute()</span>
<span class="sd">        &gt;&gt;&gt; s.info[&#39;speed&#39;]</span>
<span class="sd">        0             10.0</span>
<span class="sd">        1000000000    10.0</span>
<span class="sd">        2000000000    10.0</span>
<span class="sd">        3000000000    10.0</span>
<span class="sd">        4000000000    10.0</span>
<span class="sd">        Name: speed, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; a = s.accel(0.25)</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        SpaceCurve with 5 entries and duration 4.147319347</span>
<span class="sd">        &gt;&gt;&gt; a.compute()</span>
<span class="sd">        &gt;&gt;&gt; a.info[&#39;speed&#39;]</span>
<span class="sd">        0              7.500000</span>
<span class="sd">        1333333333     8.250000</span>
<span class="sd">        2424242424     9.930556</span>
<span class="sd">        3347319347    11.607143</span>
<span class="sd">        4147319347    12.500000</span>
<span class="sd">        Name: speed, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; a.data</span>
<span class="sd">                        time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0           0.000000    0.0    0.0    0.0       -1</span>
<span class="sd">        1333333333  1.333333   10.0    0.0    0.0       -1</span>
<span class="sd">        2424242424  2.424242   20.0    0.0    0.0       -1</span>
<span class="sd">        3347319347  3.347319   30.0    0.0    0.0       -1</span>
<span class="sd">        4147319347  4.147319   40.0    0.0    0.0       -1</span>
<span class="sd">        &gt;&gt;&gt; b = s.accel(-0.25) </span>
<span class="sd">        &gt;&gt;&gt; b</span>
<span class="sd">        SpaceCurve with 5 entries and duration 4.147319347</span>
<span class="sd">        &gt;&gt;&gt; b.compute()</span>
<span class="sd">        &gt;&gt;&gt; b.info[&#39;speed&#39;]</span>
<span class="sd">        0             12.500000</span>
<span class="sd">        800000000     11.607143</span>
<span class="sd">        1723076923     9.930556</span>
<span class="sd">        2813986013     8.250000</span>
<span class="sd">        4147319347     7.500000</span>
<span class="sd">        Name: speed, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; b.data</span>
<span class="sd">                        time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0           0.000000    0.0    0.0    0.0       -1</span>
<span class="sd">        800000000   0.800000   10.0    0.0    0.0       -1</span>
<span class="sd">        1723076923  1.723077   20.0    0.0    0.0       -1</span>
<span class="sd">        2813986013  2.813986   30.0    0.0    0.0       -1</span>
<span class="sd">        4147319347  4.147319   40.0    0.0    0.0       -1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">change_of_speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">rate</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="n">rate</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_Dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">/</span><span class="n">change_of_speed</span>
        <span class="n">accum_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">new_Dt</span><span class="p">)</span>
        
        <span class="n">new_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">new_ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_ts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">accum_time</span> <span class="o">+</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">new_tn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">new_ts</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SpaceCurve</span><span class="p">(</span><span class="n">new_tn</span><span class="p">,</span>
                          <span class="n">px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                          <span class="n">py</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                          <span class="n">pz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Apply a matrix (NumPy array) to the positions to produce a new </span>
<span class="sd">        SpaceCurve.  Used for rotating SpaceCurves.</span>
<span class="sd">        Note that this is the LEFT action from a group-theory perspective.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; sc = SpaceCurve(np.arange(4)*10**9, px=np.arange(4))</span>
<span class="sd">        &gt;&gt;&gt; sc.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0    0.0    0.0    0.0       -1</span>
<span class="sd">        1000000000   1.0    1.0    0.0    0.0       -1</span>
<span class="sd">        2000000000   2.0    2.0    0.0    0.0       -1</span>
<span class="sd">        3000000000   3.0    3.0    0.0    0.0       -1</span>
<span class="sd">        &gt;&gt;&gt; g = np.array([[np.cos(np.pi/6), -np.sin(np.pi/6), 0],</span>
<span class="sd">        ...               [np.sin(np.pi/6),  np.cos(np.pi/6), 0],</span>
<span class="sd">        ...               [         0,           0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; sc2 = sc.__matmul__(g).__matmul__(g).__matmul__(g) # use @ in Py3</span>
<span class="sd">        &gt;&gt;&gt; np.all(sc2.data[&#39;pos_y&#39;].values == sc.data[&#39;pos_x&#39;].values)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
       
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_y&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">new_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SpaceCurve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                          <span class="n">px</span><span class="o">=</span><span class="n">new_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="n">py</span><span class="o">=</span><span class="n">new_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                          <span class="n">pz</span><span class="o">=</span><span class="n">new_pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Concatenate SpaceCurves, end-to-end in space and time. The other</span>
<span class="sd">        SpaceCurve is set to begin at a time and position where self ends.</span>
<span class="sd">        This way, the number of points shrinks by one, but the total duration</span>
<span class="sd">        adds.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; sc1 = SpaceCurve(np.arange(4)*10**9, px=np.arange(4), py=2*np.arange(4))</span>
<span class="sd">        &gt;&gt;&gt; sc1</span>
<span class="sd">        SpaceCurve with 4 entries and duration 3.000000000</span>
<span class="sd">        &gt;&gt;&gt; sc1.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0    0.0    0.0    0.0       -1</span>
<span class="sd">        1000000000   1.0    1.0    2.0    0.0       -1</span>
<span class="sd">        2000000000   2.0    2.0    4.0    0.0       -1</span>
<span class="sd">        3000000000   3.0    3.0    6.0    0.0       -1</span>
<span class="sd">        &gt;&gt;&gt; sc2 = SpaceCurve(np.arange(8)*10**8, px=np.arange(0,0.4,0.05), py=3*np.arange(8))</span>
<span class="sd">        &gt;&gt;&gt; sc2</span>
<span class="sd">        SpaceCurve with 8 entries and duration .700000000</span>
<span class="sd">        &gt;&gt;&gt; sc2.data</span>
<span class="sd">                   time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0           0.0   0.00    0.0    0.0       -1</span>
<span class="sd">        100000000   0.1   0.05    3.0    0.0       -1</span>
<span class="sd">        200000000   0.2   0.10    6.0    0.0       -1</span>
<span class="sd">        300000000   0.3   0.15    9.0    0.0       -1</span>
<span class="sd">        400000000   0.4   0.20   12.0    0.0       -1</span>
<span class="sd">        500000000   0.5   0.25   15.0    0.0       -1</span>
<span class="sd">        600000000   0.6   0.30   18.0    0.0       -1</span>
<span class="sd">        700000000   0.7   0.35   21.0    0.0       -1</span>
<span class="sd">        &gt;&gt;&gt; sc3 = sc1 + sc2</span>
<span class="sd">        &gt;&gt;&gt; sc3</span>
<span class="sd">        SpaceCurve with 11 entries and duration 3.700000000</span>
<span class="sd">        &gt;&gt;&gt; sc3.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0   0.00    0.0    0.0       -1</span>
<span class="sd">        1000000000   1.0   1.00    2.0    0.0       -1</span>
<span class="sd">        2000000000   2.0   2.00    4.0    0.0       -1</span>
<span class="sd">        3000000000   3.0   3.00    6.0    0.0       -1</span>
<span class="sd">        3100000000   3.1   3.05    9.0    0.0       -1</span>
<span class="sd">        3200000000   3.2   3.10   12.0    0.0       -1</span>
<span class="sd">        3300000000   3.3   3.15   15.0    0.0       -1</span>
<span class="sd">        3400000000   3.4   3.20   18.0    0.0       -1</span>
<span class="sd">        3500000000   3.5   3.25   21.0    0.0       -1</span>
<span class="sd">        3600000000   3.6   3.30   24.0    0.0       -1</span>
<span class="sd">        3700000000   3.7   3.35   27.0    0.0       -1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">tn_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">px_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">py_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pz_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">new_tn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                 <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">tn_shift</span><span class="p">])</span>
        <span class="n">new_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                 <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">px_shift</span><span class="p">])</span>
        <span class="n">new_py</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                 <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">py_shift</span><span class="p">])</span>
        <span class="n">new_pz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                 <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">pz_shift</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_tn</span><span class="p">,</span> <span class="n">px</span><span class="o">=</span><span class="n">new_px</span><span class="p">,</span> <span class="n">py</span><span class="o">=</span><span class="n">new_py</span><span class="p">,</span> <span class="n">pz</span><span class="o">=</span><span class="n">new_pz</span><span class="p">)</span>
 
<div class="viewcode-block" id="SpaceCurve.arclength_param"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.arclength_param.html#timeseries.SpaceCurve.arclength_param">[docs]</a>    <span class="k">def</span> <span class="nf">arclength_param</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Change time parametrization to the universal speed=1 arclength</span>
<span class="sd">        parametrization.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tn = np.arange(0, 5e9, 1e9)</span>
<span class="sd">        &gt;&gt;&gt; s = SpaceCurve(tn=tn, px=(tn/1e9)**2)</span>
<span class="sd">        &gt;&gt;&gt; s.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0    0.0    0.0    0.0       -1</span>
<span class="sd">        1000000000   1.0    1.0    0.0    0.0       -1</span>
<span class="sd">        2000000000   2.0    4.0    0.0    0.0       -1</span>
<span class="sd">        3000000000   3.0    9.0    0.0    0.0       -1</span>
<span class="sd">        4000000000   4.0   16.0    0.0    0.0       -1</span>
<span class="sd">        &gt;&gt;&gt; a = s.arclength_param()</span>
<span class="sd">        &gt;&gt;&gt; a.data</span>
<span class="sd">                     time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0             0.0    0.0    0.0    0.0       -1</span>
<span class="sd">        1000000000    1.0    1.0    0.0    0.0       -1</span>
<span class="sd">        4000000000    4.0    4.0    0.0    0.0       -1</span>
<span class="sd">        9000000000    9.0    9.0    0.0    0.0       -1</span>
<span class="sd">        16000000000  16.0   16.0    0.0    0.0       -1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_y&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gap</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">accum_time</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">new_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">new_ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_ts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">accum_time</span> <span class="o">+</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_tn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">new_ts</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SpaceCurve</span><span class="p">(</span><span class="n">new_tn</span><span class="p">,</span>
                          <span class="n">px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                          <span class="n">py</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                          <span class="n">pz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpaceCurve.reverse"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.reverse.html#timeseries.SpaceCurve.reverse">[docs]</a>    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse the time parametrization of the SpaceCurve.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; tn = np.arange(0, 5*1e9, 1e9)</span>
<span class="sd">        &gt;&gt;&gt; s = SpaceCurve(tn=tn, px=10.0*tn/1e9) # drive straight at 10m/s</span>
<span class="sd">        &gt;&gt;&gt; s.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0    0.0    0.0    0.0       -1</span>
<span class="sd">        1000000000   1.0   10.0    0.0    0.0       -1</span>
<span class="sd">        2000000000   2.0   20.0    0.0    0.0       -1</span>
<span class="sd">        3000000000   3.0   30.0    0.0    0.0       -1</span>
<span class="sd">        4000000000   4.0   40.0    0.0    0.0       -1</span>
<span class="sd">        &gt;&gt;&gt; a = s.reverse()</span>
<span class="sd">        &gt;&gt;&gt; a.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0   40.0    0.0    0.0       -1</span>
<span class="sd">        1000000000   1.0   30.0    0.0    0.0       -1</span>
<span class="sd">        2000000000   2.0   20.0    0.0    0.0       -1</span>
<span class="sd">        3000000000   3.0   10.0    0.0    0.0       -1</span>
<span class="sd">        4000000000   4.0    0.0    0.0    0.0       -1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SpaceCurve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                          <span class="n">px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">py</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">pz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="SpaceCurve.reparam"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.reparam.html#timeseries.SpaceCurve.reparam">[docs]</a>    <span class="k">def</span> <span class="nf">reparam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Change time parametrization, to represent a constant change of speed.</span>
<span class="sd">        Locations, initial time, and arc-length are preserved.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rate : float</span>
<span class="sd">            A (positive) ratio by which to increase the speed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If :code:`speed[i]` changes to :code:`speed[i]*q[i]`, then</span>
<span class="sd">        :code:`delta_t[i]` changes to :code:`delta_t[i]*p[i]`, where </span>
<span class="sd">        :code:`p[i] = 1 / q[i]`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tn = np.arange(0, 5*1e9, 1e9)</span>
<span class="sd">        &gt;&gt;&gt; s = SpaceCurve(tn=tn, px=10.0*tn/1e9) # drive straight at 10m/s</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        SpaceCurve with 5 entries and duration 4.000000000</span>
<span class="sd">        &gt;&gt;&gt; s.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0    0.0    0.0    0.0       -1</span>
<span class="sd">        1000000000   1.0   10.0    0.0    0.0       -1</span>
<span class="sd">        2000000000   2.0   20.0    0.0    0.0       -1</span>
<span class="sd">        3000000000   3.0   30.0    0.0    0.0       -1</span>
<span class="sd">        4000000000   4.0   40.0    0.0    0.0       -1</span>
<span class="sd">        &gt;&gt;&gt; a = s.reparam(0.5)</span>
<span class="sd">        &gt;&gt;&gt; a.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0    0.0    0.0    0.0       -1</span>
<span class="sd">        2000000000   2.0   10.0    0.0    0.0       -1</span>
<span class="sd">        4000000000   4.0   20.0    0.0    0.0       -1</span>
<span class="sd">        6000000000   6.0   30.0    0.0    0.0       -1</span>
<span class="sd">        8000000000   8.0   40.0    0.0    0.0       -1</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        SpaceCurve with 5 entries and duration 8.000000000</span>
<span class="sd">        &gt;&gt;&gt; b = s.reparam(2.0) </span>
<span class="sd">        &gt;&gt;&gt; b</span>
<span class="sd">        SpaceCurve with 5 entries and duration 2.000000000</span>
<span class="sd">        &gt;&gt;&gt; b.data</span>
<span class="sd">                    time  pos_x  pos_y  pos_z  quality</span>
<span class="sd">        0            0.0    0.0    0.0    0.0       -1</span>
<span class="sd">        500000000    0.5   10.0    0.0    0.0       -1</span>
<span class="sd">        1000000000   1.0   20.0    0.0    0.0       -1</span>
<span class="sd">        1500000000   1.5   30.0    0.0    0.0       -1</span>
<span class="sd">        2000000000   2.0   40.0    0.0    0.0       -1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">new_ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">/</span><span class="n">rate</span>
        <span class="n">new_tn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">new_ts</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SpaceCurve</span><span class="p">(</span><span class="n">new_tn</span><span class="p">,</span>
                          <span class="n">px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                          <span class="n">py</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                          <span class="n">pz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpaceCurve.plot"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.plot.html#timeseries.SpaceCurve.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;SpaceCurve&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Plot the SpaceCurve in 3D.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        canvas : :class:`matplotlib.axes._subplots.AxesSubplot`</span>
<span class="sd">                Be sure that 3D plotting is enabled on this canvas, with</span>
<span class="sd">                :code:`mpl_toolkits.mplot3d import Axes3D` and </span>
<span class="sd">                :code:`canvas = matplotlib.pyplot.subplot(projection=&#39;3d&#39;)`</span>
<span class="sd">        title : str</span>
<span class="sd">                A title for the figure.</span>
<span class="sd">        color : str</span>
<span class="sd">                The name of a color for the points to draw.  Passed to the</span>
<span class="sd">                appropriate drawing library (bokeh or matplotlib).</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Because we are using ECEF coordinates, the horizontal projection should</span>
<span class="sd">        be taken as an approximation!</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">canvas</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;bokeh.plotting.figure&#39;</span><span class="p">:</span>
            <span class="n">canvas_type</span> <span class="o">=</span> <span class="s2">&quot;bokeh&quot;</span>
            <span class="kn">import</span> <span class="nn">bokeh.plotting</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">canvas</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;matplotlib.axes._subplots&#39;</span><span class="p">:</span>
            <span class="n">canvas_type</span> <span class="o">=</span> <span class="s2">&quot;pyplot&quot;</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">Axes3D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;canvas must be a bokeh.plotting.figure() or a matplotlib.pyplot.subplots()[1].  You gave me </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">canvas</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="c1">#if canvas_type == &quot;bokeh&quot;:</span>
        <span class="c1">#    canvas.title = title</span>
        <span class="c1">#elif canvas_type == &quot;pyplot&quot;:</span>
        <span class="c1">#    canvas.set_title(title)</span>

        <span class="c1"># transform to local ENU coordinates at every point, and start at 0.</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_y&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">canvas_type</span> <span class="o">==</span> <span class="s2">&quot;pyplot&quot;</span><span class="p">:</span>
            <span class="n">canvas</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">pass</span></div>

<div class="viewcode-block" id="SpaceCurve.slide"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.slide.html#timeseries.SpaceCurve.slide">[docs]</a>    <span class="k">def</span> <span class="nf">slide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span><span class="p">,</span>
              <span class="n">time_step</span><span class="o">=</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span><span class="p">,</span>
              <span class="n">time_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">time_stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">overlap_ends</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Produce equal-time SpaceCurves using a sliding-window on self.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        window : int</span>
<span class="sd">            length of window in nanoseconds (default = 60*10**9 or 1 minute)</span>
<span class="sd">        time_step : int</span>
<span class="sd">            step size in nanoseconds between window starting-points (default = 1*10** or 1 second)</span>
<span class="sd">        time_start : int</span>
<span class="sd">            start time in nanoseconds (default = None, min time)</span>
<span class="sd">        time_stop : int</span>
<span class="sd">            stop time in nanoseconds (default = None, max time)</span>
<span class="sd">        overlap_ends : bool</span>
<span class="sd">            Should endpoints overlap (True) or abutt (False) (default = True)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iterator of SpaceCurves</span>
<span class="sd">        To access the tracks as a list, do</span>
<span class="sd">        :code:`list( FT.snip() )`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The trackids are unchanged! You might want to change them manually.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">time_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">time_stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">overlap_ends</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">time_start</span><span class="p">,</span> <span class="n">time_stop</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">start_ns</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
            <span class="n">stop_ns</span> <span class="o">=</span> <span class="n">start_ns</span> <span class="o">+</span> <span class="n">window</span>
            <span class="n">newFT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">newFT</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start_ns</span><span class="p">:</span><span class="n">stop_ns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">newFT</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start_ns</span><span class="p">:</span><span class="n">stop_ns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">newFT</span>

            <span class="k">if</span> <span class="n">stop_ns</span> <span class="o">&gt;=</span> <span class="n">time_stop</span><span class="p">:</span>
                <span class="k">break</span></div>

<div class="viewcode-block" id="SpaceCurve.snip"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.snip.html#timeseries.SpaceCurve.snip">[docs]</a>    <span class="k">def</span> <span class="nf">snip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span><span class="p">,</span> <span class="n">time_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">overlap_ends</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cut this SpaceCurve into equal-time snippets.</span>
<span class="sd">        This is just a simple wrapper around self.slide( )</span>
<span class="sd">        with time_step == window.</span>

<span class="sd">        time_step=60*10**9 == 1 minute</span>

<span class="sd">        Note! The trackids are unchanged!</span>
<span class="sd">        You might want to change them manually.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        iterator of SpaceCurves</span>
<span class="sd">        To access the tracks as a list, do</span>
<span class="sd">        list( FT.snip() )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">F</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">time_step</span><span class="p">,</span>
                            <span class="n">time_step</span><span class="o">=</span><span class="n">time_step</span><span class="p">,</span>
                            <span class="n">time_start</span><span class="o">=</span><span class="n">time_start</span><span class="p">,</span>
                            <span class="n">time_stop</span><span class="o">=</span><span class="n">time_stop</span><span class="p">,</span>
                            <span class="n">overlap_ends</span><span class="o">=</span><span class="n">overlap_ends</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">F</span></div>

<div class="viewcode-block" id="SpaceCurve.clean_copy"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.clean_copy.html#timeseries.SpaceCurve.clean_copy">[docs]</a>    <span class="k">def</span> <span class="nf">clean_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cleanup_func</span><span class="o">=</span><span class="n">curve_geometry</span><span class="o">.</span><span class="n">mollifier</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Make copy in which a cleanup function performed</span>
<span class="sd">        on the data.</span>

<span class="sd">        cleanup_func is the interface to the functions in curve_geometry.</span>
<span class="sd">        In particular:</span>
<span class="sd">        1. :func:`curve_geometry.cleanup` does slope comparison</span>
<span class="sd">        2. :func:`curve_geometry.mollifier` does a convolution</span>

<span class="sd">        cleanup_func should at the minimum take time and position as</span>
<span class="sd">        positional arguments 1 and 2 and return both new time and new</span>
<span class="sd">        position arrays.  All Keyword arguments (:code:`**kwargs`) are passed on to</span>
<span class="sd">        cleanup_func.</span>

<span class="sd">        One can tune the various cleanup functions by passing</span>
<span class="sd">        a user manufactured function, for example</span>
<span class="sd">        .. code::</span>
<span class="sd">            </span>
<span class="sd">            my_cleanup = lambda time, x:curve_geometry.mollifier(time,x,width=0.5)</span>
<span class="sd">            clean_track = track.clean_copy(cleanup_func = my_cleanup)</span>
<span class="sd">        </span>
<span class="sd">        would be equivalent to</span>
<span class="sd">        .. code::</span>
<span class="sd">        </span>
<span class="sd">            clean_track = track.clean_copy(cleanup_func=curve_geometry.mollifier, width=0.5)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute the cleaned up values</span>
        <span class="n">time</span><span class="p">,</span> <span class="n">clean_px</span> <span class="o">=</span> <span class="n">cleanup_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">timey</span><span class="p">,</span> <span class="n">clean_py</span> <span class="o">=</span> <span class="n">cleanup_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">timez</span><span class="p">,</span> <span class="n">clean_pz</span> <span class="o">=</span> <span class="n">cleanup_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">time</span> <span class="o">==</span> <span class="n">timey</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">time</span> <span class="o">==</span> <span class="n">timez</span><span class="p">)</span>

        <span class="c1"># [time, clean_vx] = cleanup_func(self.data[&#39;time&#39;].values,</span>
        <span class="c1">#                                self.data[&#39;vel_x&#39;].values)</span>
        <span class="c1"># [time, clean_vy] = cleanup_func(self.data[&#39;time&#39;].values,</span>
        <span class="c1">#                                self.data[&#39;vel_y&#39;].values)</span>
        <span class="c1"># [time, clean_vz] = cleanup_func(self.data[&#39;time&#39;].values,</span>
        <span class="c1">#                                self.data[&#39;vel_z&#39;].values)</span>

        <span class="c1"># Build a new index from the time array</span>
        <span class="n">new_index_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">time</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">)</span><span class="o">+</span><span class="n">new_index_start</span>

        <span class="k">assert</span> <span class="n">new_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
            <span class="sd">&quot;&quot;&quot;New index is shape {} but time is shape {}&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


        <span class="c1"># Instantiate a new flighttrack object from the cleaned versions</span>
        <span class="n">newFT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span>
                               <span class="n">trackid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trackid</span><span class="p">,</span>
                               <span class="n">platform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span>
                               <span class="n">activity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activity</span><span class="p">,</span>
                               <span class="n">mollified</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">newFT</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
                                   <span class="s1">&#39;pos_x&#39;</span><span class="p">:</span> <span class="n">clean_px</span><span class="p">,</span>
                                   <span class="s1">&#39;pos_y&#39;</span><span class="p">:</span> <span class="n">clean_py</span><span class="p">,</span>
                                   <span class="s1">&#39;pos_z&#39;</span><span class="p">:</span> <span class="n">clean_pz</span><span class="p">,</span>
                                   <span class="s1">&#39;quality&#39;</span><span class="p">:</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)},</span>
                                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_x&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_y&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_z&#39;</span><span class="p">,</span> <span class="s1">&#39;quality&#39;</span><span class="p">],</span>
                                  <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newFT</span></div>

<div class="viewcode-block" id="SpaceCurve.compute"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.compute.html#timeseries.SpaceCurve.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute some nice invariants and store them to self.info. </span>
<span class="sd">        Vector quantities are generally in the fixed frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># raw data in ECEF frame.</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_y&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">curve_geometry</span><span class="o">.</span><span class="n">secant_derivative</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
        <span class="c1">#V2 = self.data[[&#39;vel_x&#39;, &#39;vel_y&#39;, &#39;vel_z&#39;]].values</span>
        <span class="c1">#assert not np.any(np.isnan(V2)), &quot;{} bad in {}&quot;.format(np.where(np.isnan(V2)), V2.shape)</span>

        <span class="c1"># all derivatives and integrals</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">curve_geometry</span><span class="o">.</span><span class="n">secant_derivative</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">curve_geometry</span><span class="o">.</span><span class="n">secant_derivative</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">arclengthS</span> <span class="o">=</span> <span class="n">curve_geometry</span><span class="o">.</span><span class="n">secant_arclength</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

        <span class="c1"># norms</span>
        <span class="c1">#recspeed = np.linalg.norm(V2, axis=1).flatten()</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">jerk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># Use signature curve to make curv and tors</span>
            <span class="n">kap</span><span class="p">,</span> <span class="n">kap_s</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">tau_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signature_curve</span><span class="p">()</span>
       
        <span class="c1">#KT = np.ndarray(shape=(T.shape[0], 2), dtype=&#39;float&#39;)</span>
        <span class="c1">#KT[:2, :] = sc[0, :]</span>
        <span class="c1">#KT[:-2, :] = sc[-1, :]</span>
        <span class="c1">#KT[2:-2, :] = sc</span>


        <span class="c1">#TNB_enu = curve_geometry.frenet_frame(V, A)</span>
        <span class="c1">#tilt = np.arccos(np.abs(TNB_enu[:, 2, 2]))</span>

        <span class="c1">#dKT_ds = curve_geometry.secant_derivative(arclengthS, KT)</span>
        <span class="c1">#tilt_array = tilt.copy()</span>
        <span class="c1">#tilt_array.shape = (tilt.shape[0], 1)</span>
        <span class="c1">#dtilt_ds = curve_geometry.secant_derivative(arclengthS,</span>
        <span class="c1">#tilt_array).flatten()</span>

<span class="c1">#        curv_per_alt = KT[:, 0] / (P[:,2]+1)</span>
<span class="c1">#        acc_per_alt = acc / (P[:,2]+1)</span>
<span class="c1">#        tors_per_alt = KT[:, 1] / (P[:,2]+1)</span>
        <span class="c1">#print(tau.shape)</span>
        <span class="c1">#print(kap_s.shape)</span>
        <span class="c1">#print(tau.shape)</span>
        <span class="c1">#print(tau_s.shape)</span>
<span class="c1">#        friction = kap * speed ** 2  ## need to check this for angle.</span>
<span class="c1">#        bank = np.arctan(friction / 9.8)  ## replace 9.8 with gravity??</span>

        
        <span class="c1"># dKT_ds = curve_geometry.secant_derivative(arclengthS, KT)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;vel_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;vel_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;vel_z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;acc_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;acc_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;acc_z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arclengthS</span>  <span class="c1"># This is the only thing we store in data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">speed</span>
        <span class="c1">#self.info[&#39;recspeed&#39;] = recspeed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;acc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">acc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;jerk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jerk</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;curv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kap</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;curv_s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kap_s</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;tors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;tors_s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1">#self.info[&#39;tors_s&#39;].values[3:-3] = tau_s</span>
        <span class="c1">#self.info[&#39;tors_s&#39;].values[:3] = tau_s[0]</span>
        <span class="c1">#self.info[&#39;tors_s&#39;].values[-3:] = tau_s[-1]</span>


        <span class="c1">#self.info[&#39;tors&#39;] = tau</span>
        <span class="c1">#self.info[&#39;dKds&#39;] = curv_s</span>
        <span class="c1">#self.info[&#39;dTds&#39;] = tau_s</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SpaceCurve.featurize"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.featurize.html#timeseries.SpaceCurve.featurize">[docs]</a>    <span class="k">def</span> <span class="nf">featurize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_and_grab_num</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A convenience function to compute everything we think might be</span>
<span class="sd">        important.  This returns a dictionary of np arrays. </span>
<span class="sd">        Optionally, we can hit all of the persistence diagrams with sort+grab.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">feature_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;curv&#39;</span><span class="p">,</span> <span class="s1">&#39;tors&#39;</span><span class="p">,</span> <span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;acc&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;Dcurv/Dlen&#39;</span><span class="p">,</span> <span class="s1">&#39;Dtors/Dlen&#39;</span><span class="p">,</span> <span class="s1">&#39;Dup/Dlen&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;speed&#39;</span><span class="p">,</span> <span class="s1">&#39;friction&#39;</span><span class="p">,</span> <span class="s1">&#39;curv/alt&#39;</span><span class="p">,</span> <span class="s1">&#39;tors/alt&#39;</span><span class="p">,</span> <span class="s1">&#39;acc/alt&#39;</span><span class="p">,</span>
                     <span class="p">]:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sort_and_grab_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">feature_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">grab</span><span class="p">(</span><span class="n">sort_and_grab_num</span><span class="p">)[</span><span class="s1">&#39;keepcode&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">feature_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">diagram</span>

        <span class="k">return</span> <span class="n">feature_dict</span></div>

<div class="viewcode-block" id="SpaceCurve.copy"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.copy.html#timeseries.SpaceCurve.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; make an identical copy of self. &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newFT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">trackid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trackid</span><span class="p">,</span>
                               <span class="n">platform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span>
                               <span class="n">activity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activity</span><span class="p">,</span>
                               <span class="p">)</span>
        <span class="n">newFT</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">newFT</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">newFT</span></div>

<div class="viewcode-block" id="SpaceCurve.load"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.load.html#timeseries.SpaceCurve.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simple CSV reader.</span>
<span class="sd">        columns (&#39;time&#39;, &#39;pos_x&#39;, &#39;pos_y&#39;, &#39;pos_z&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tn</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">px</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">py</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">pz</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span></div>

<div class="viewcode-block" id="SpaceCurve.duration"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.duration.html#timeseries.SpaceCurve.duration">[docs]</a>    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return string of duraction of SpaceCurve,</span>
<span class="sd">        converting integer nanoseconds to string seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">ns</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">seconds</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[:</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">ns</span><span class="p">[</span><span class="o">-</span><span class="mi">9</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">seconds</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;SpaceCurve with </span><span class="si">{}</span><span class="s2"> entries and duration </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">())</span>

<div class="viewcode-block" id="SpaceCurve.mass_profile"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.mass_profile.html#timeseries.SpaceCurve.mass_profile">[docs]</a>    <span class="k">def</span> <span class="nf">mass_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">underflow</span><span class="o">=-</span><span class="mi">50</span><span class="p">,</span> <span class="n">overflow</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; histogram of the lift_and_mass by mass. &quot;&quot;&quot;</span>

        <span class="n">LM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lift_and_mass</span><span class="p">()</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">overflow</span> <span class="o">-</span> <span class="n">underflow</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>

        <span class="n">finite_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">underflow</span><span class="p">,</span> <span class="n">overflow</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">finite_bins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,))</span>
        <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
        <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">finite_bins</span><span class="p">[:]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">LM</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpaceCurve.lift_profile"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.lift_profile.html#timeseries.SpaceCurve.lift_profile">[docs]</a>    <span class="k">def</span> <span class="nf">lift_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">underflow</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overflow</span><span class="o">=</span><span class="mi">500000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; histogram of the lift_and_mass by lift. &quot;&quot;&quot;</span>
        <span class="n">LM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lift_and_mass</span><span class="p">()</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">overflow</span> <span class="o">-</span> <span class="n">underflow</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>

        <span class="n">finite_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">underflow</span><span class="p">,</span> <span class="n">overflow</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">finite_bins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,))</span>
        <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
        <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">finite_bins</span><span class="p">[:]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">LM</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpaceCurve.lift_and_mass"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.lift_and_mass.html#timeseries.SpaceCurve.lift_and_mass">[docs]</a>    <span class="k">def</span> <span class="nf">lift_and_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Produce the terms of the force-balance equations, to help derive</span>
<span class="sd">        coefficient-of-lift and mass from pure trajectory information.</span>

<span class="sd">        Consider an aircraft flying with velocity :math:`v`, banking angle</span>
<span class="sd">        :math:`\theta`, air density :math:`\rho`, mass :math:`m`, gravity</span>
<span class="sd">        :math:`g`, vertical acceleration :math:`\ddot{z}`, and lift coefficient</span>
<span class="sd">        :math:`C_{\text{lift}}`.</span>

<span class="sd">        The force-balance equation is </span>
<span class="sd">        ..math:: </span>

<span class="sd">            LHS = \frac12 \|v\|^2 \, \cos(\theta)\, \rho</span>
<span class="sd">            RHS = (g + \ddot{z})</span>
<span class="sd">            LHS\, C_{\text{lift}} = RHS\, m</span>
<span class="sd">      </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coefficients : :class:np.array</span>
<span class="sd">            the columns are LHS and RHS. </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># build an atmospheric air density profile using the data</span>
        <span class="c1"># 1976 international standard atmosphere.  We just use a 4th-order fit.</span>
        <span class="c1"># https://en.wikipedia.org/wiki/International_Standard_Atmosphere</span>
        <span class="c1"># alts = np.array([-610, 11000, 20000, 32000,47000])</span>
        <span class="c1"># dens = np.array([1.2985,0.3639,0.0880,.0105,0.0020])</span>
        <span class="c1"># air_denstiy = np.poly1d(np.polyfit(alts,dens,4))</span>
        <span class="n">air_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mf">2.70588959e-19</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.57103078e-14</span><span class="p">,</span> <span class="mf">3.91598431e-09</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.15140013e-04</span><span class="p">,</span> <span class="mf">1.22679477e+00</span><span class="p">])</span>

        <span class="n">speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">altacc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;acc_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">bank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bank&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">cosb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">bank</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;alt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">air</span> <span class="o">=</span> <span class="n">air_density</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">LHS</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">speed</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cosb</span> <span class="o">*</span> <span class="n">air</span>
        <span class="n">RHS</span> <span class="o">=</span> <span class="mf">9.8</span> <span class="o">+</span> <span class="n">altacc</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">])</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="SpaceCurve.auto_bin"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.auto_bin.html#timeseries.SpaceCurve.auto_bin">[docs]</a>    <span class="k">def</span> <span class="nf">auto_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">underflow</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overflow</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Count bins on the transformed persistence diagrams of </span>
<span class="sd">        -Speed/7         (so it is expected to be between 0 and 100)</span>
<span class="sd">        -Climb/3         (so it is expected to be between 0 and 100)</span>
<span class="sd">        -Curvature*10000 (so it is expected to be between 0 and 100)</span>
<span class="sd">        -Torsion*10000   (so it is expected to be between 0 and 100)</span>
<span class="sd">        -Bank*100/(pi/4) (==grade, between 0 and 100)</span>

<span class="sd">        Bins are added for (-inf, underflow] and (overflow,inf).</span>
<span class="sd">        If underflow and overflow are not provided, they are set to min/max.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">speed01</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">climb01</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;climb&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">curv01</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;curv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span>
        <span class="n">tors01</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;tors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span>
        <span class="n">bank01</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bank&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="mi">400</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">overflow</span> <span class="o">-</span> <span class="n">underflow</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>

        <span class="n">speed_hist</span><span class="p">,</span> <span class="n">speed_bins</span> <span class="o">=</span> <span class="n">speed01</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">bin</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                                                  <span class="n">underflow</span><span class="o">=</span><span class="n">underflow</span><span class="p">,</span>
                                                  <span class="n">overflow</span><span class="o">=</span><span class="n">overflow</span><span class="p">)</span>
        <span class="n">climb_hist</span><span class="p">,</span> <span class="n">climb_bins</span> <span class="o">=</span> <span class="n">climb01</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">bin</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                                                  <span class="n">underflow</span><span class="o">=</span><span class="n">underflow</span><span class="p">,</span>
                                                  <span class="n">overflow</span><span class="o">=</span><span class="n">overflow</span><span class="p">)</span>
        <span class="n">curv_hist</span><span class="p">,</span> <span class="n">curv_bins</span> <span class="o">=</span> <span class="n">curv01</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">bin</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                                               <span class="n">underflow</span><span class="o">=</span><span class="n">underflow</span><span class="p">,</span>
                                               <span class="n">overflow</span><span class="o">=</span><span class="n">overflow</span><span class="p">)</span>
        <span class="n">tors_hist</span><span class="p">,</span> <span class="n">tors_bins</span> <span class="o">=</span> <span class="n">tors01</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">bin</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                                               <span class="n">underflow</span><span class="o">=</span><span class="n">underflow</span><span class="p">,</span>
                                               <span class="n">overflow</span><span class="o">=</span><span class="n">overflow</span><span class="p">)</span>
        <span class="n">bank_hist</span><span class="p">,</span> <span class="n">bank_bins</span> <span class="o">=</span> <span class="n">bank01</span><span class="o">.</span><span class="n">pers</span><span class="o">.</span><span class="n">bin</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                                               <span class="n">underflow</span><span class="o">=</span><span class="n">underflow</span><span class="p">,</span>
                                               <span class="n">overflow</span><span class="o">=</span><span class="n">overflow</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">curv_bins</span> <span class="o">==</span> <span class="n">tors_bins</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="n">curv_bins</span> <span class="o">==</span> <span class="n">bank_bins</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;bins&#39;</span><span class="p">:</span> <span class="n">curv_bins</span><span class="p">,</span>
                <span class="s1">&#39;speed&#39;</span><span class="p">:</span> <span class="n">speed_hist</span><span class="p">,</span>
                <span class="s1">&#39;climb&#39;</span><span class="p">:</span> <span class="n">climb_hist</span><span class="p">,</span>
                <span class="s1">&#39;curv&#39;</span><span class="p">:</span> <span class="n">curv_hist</span><span class="p">,</span>
                <span class="s1">&#39;tors&#39;</span><span class="p">:</span> <span class="n">tors_hist</span><span class="p">,</span>
                <span class="s1">&#39;bank&#39;</span><span class="p">:</span> <span class="n">bank_hist</span><span class="p">}</span></div>

<div class="viewcode-block" id="SpaceCurve.signature_curve"><a class="viewcode-back" href="../generated/timeseries.SpaceCurve.signature_curve.html#timeseries.SpaceCurve.signature_curve">[docs]</a>    <span class="k">def</span> <span class="nf">signature_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Olver/Boutin signature curve.</span>
<span class="sd">        (kappa, kappa_s, tau, tau_s)</span>
<span class="sd">        due to difference methods, the lengths are (n-2, n-4, n-4, n-6),</span>
<span class="sd">        but we pad them all to length n</span>

<span class="sd">        Usage:</span>
<span class="sd">        ------</span>
<span class="sd">        &gt;&gt;&gt; ts = np.arange(0,12,0.1)</span>
<span class="sd">        &gt;&gt;&gt; # Line</span>
<span class="sd">        &gt;&gt;&gt; C = SpaceCurve(tn = np.arange(ts.shape[0]),</span>
<span class="sd">        ...                px = 5*ts + 3, py=2*ts + 5)</span>
<span class="sd">        &gt;&gt;&gt; kappa, kappa_s, tau, tau_s = C.signature_curve()</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa, 0.0, atol=1.5e-7)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa_s, 0.0, atol=1.5e-7)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(tau, 0.0, atol=1.5e-7)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(tau_s, 0.0, atol=1.5e-7)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ts = np.arange(0,12,0.1)</span>
<span class="sd">        &gt;&gt;&gt; # Circle with constant speed</span>
<span class="sd">        &gt;&gt;&gt; C = SpaceCurve(tn = np.arange(ts.shape[0]),</span>
<span class="sd">        ...                px = np.cos(ts),</span>
<span class="sd">        ...                py = np.sin(ts))</span>
<span class="sd">        &gt;&gt;&gt; kappa, kappa_s, tau, tau_s = C.signature_curve()</span>
<span class="sd">        &gt;&gt;&gt; kappa.shape # padded</span>
<span class="sd">        (120,)</span>
<span class="sd">        &gt;&gt;&gt; kappa_s.shape</span>
<span class="sd">        (120,)</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa, 1.)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa_s, 0.)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ts = np.arange(0,12,0.1)</span>
<span class="sd">        &gt;&gt;&gt; # Circle with varying speed</span>
<span class="sd">        &gt;&gt;&gt; C = SpaceCurve(tn = np.arange(ts.shape[0]),</span>
<span class="sd">        ...                px = np.cos(ts**2),</span>
<span class="sd">        ...                py = np.sin(ts**2))</span>
<span class="sd">        &gt;&gt;&gt; kappa, kappa_s, tau, tau_s  = C.signature_curve()</span>
<span class="sd">        &gt;&gt;&gt; kappa_s.shape # padded</span>
<span class="sd">        (120,)</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa, 1.)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa_s, 0.)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(tau, 0.)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(tau_s, 0.)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ts = np.arange(1,13,0.01)</span>
<span class="sd">        &gt;&gt;&gt; # A Spiral</span>
<span class="sd">        &gt;&gt;&gt; C = SpaceCurve(tn = np.arange(ts.shape[0]),</span>
<span class="sd">        ...                px = np.exp(0.75*ts)*np.cos(ts),</span>
<span class="sd">        ...                py = np.exp(0.75*ts)*np.sin(ts))</span>
<span class="sd">        &gt;&gt;&gt; kappa, kappa_s, tau, tau_s = C.signature_curve()</span>
<span class="sd">        &gt;&gt;&gt; kappa.shape # padded</span>
<span class="sd">        (1200,)</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa[1:-1],  np.exp(-0.75*ts[1:-1]), atol=0.1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa_s[2:-2]*np.exp(1.5*ts[2:-2]), -12./25., atol=0.01)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; # A Helix</span>
<span class="sd">        &gt;&gt;&gt; C = SpaceCurve(tn = np.arange(ts.shape[0]),</span>
<span class="sd">        ...                px = 3*np.cos(ts),</span>
<span class="sd">        ...                py = 3*np.sin(ts),</span>
<span class="sd">        ...                pz = 4*ts)</span>
<span class="sd">        &gt;&gt;&gt; kappa, kappa_s, tau, tau_s = C.signature_curve()</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa, 3/25.)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa_s, 0.0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(tau, 4/25.)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(tau_s, 0.0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; # A Helix (reversed)</span>
<span class="sd">        &gt;&gt;&gt; C = SpaceCurve(tn = np.arange(ts.shape[0]),</span>
<span class="sd">        ...                px = 3*np.cos(-ts),</span>
<span class="sd">        ...                py = 3*np.sin(-ts),</span>
<span class="sd">        ...                pz = 4*ts)</span>
<span class="sd">        &gt;&gt;&gt; kappa, kappa_s, tau, tau_s = C.signature_curve()</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa, -3/25.,)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(kappa_s, 0.0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(tau, -4/25.,)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(tau_s, 0.0)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#if not np.all(self.data[&#39;pos_z&#39;].values == 0.):</span>
        <span class="c1">#    raise ValueError(&quot;This method currently handles only planar curves.&quot;)</span>

        <span class="c1"># if np.all(self.data[&#39;pos_x&#39;].values == 0.):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;pos_x&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_y&#39;</span><span class="p">,</span> <span class="s1">&#39;pos_z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># follow Calabi&#39;s naming convention.</span>
        <span class="c1"># We deal with 1-interior points.</span>
        <span class="n">P_i_mns_1</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">P_i</span>       <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">P_i_pls_1</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span>

        <span class="c1"># Use the determinant to set a right-handed sign.</span>
        <span class="n">triples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">triples</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">P_i_mns_1</span>
        <span class="n">triples</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">P_i</span>      
        <span class="n">triples</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">P_i_pls_1</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">triples</span><span class="p">))</span>


        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i</span>       <span class="o">-</span> <span class="n">P_i_mns_1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i_pls_1</span> <span class="o">-</span> <span class="n">P_i</span>      <span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i_pls_1</span> <span class="o">-</span> <span class="n">P_i_mns_1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">)</span>
        <span class="c1"># If a,b,c are co-linear, then we might get s-c to be negative</span>
        <span class="c1"># due to roundoff error.  (or other permutations)</span>
        <span class="n">s_minus_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">)</span>
        <span class="n">s_minus_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">)</span>
        <span class="n">s_minus_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">)</span>

        <span class="n">abc</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span>
        <span class="c1"># Calabi,et al eqn (2.2)</span>
        <span class="n">non_trivial</span> <span class="o">=</span> <span class="p">(</span><span class="n">abc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kappa</span> <span class="o">=</span> <span class="n">sign</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">s_minus_a</span><span class="o">*</span><span class="n">s_minus_b</span><span class="o">*</span><span class="n">s_minus_c</span><span class="p">)</span>
        <span class="n">kappa</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span> <span class="o">/</span> <span class="n">abc</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span>
        <span class="n">kappa</span><span class="p">[</span><span class="o">~</span> <span class="n">non_trivial</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">assert</span> <span class="n">kappa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span>

        <span class="c1"># Now, we follow Boutin&#39;s naming convention.</span>
        <span class="c1"># We deal with 2-interior points.</span>
        <span class="n">P_i</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">P_i_pls_1</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">P_i_pls_2</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">4</span><span class="p">:,</span> <span class="p">:]</span>
        <span class="n">P_i_mns_1</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">P_i_mns_2</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i</span>       <span class="o">-</span> <span class="n">P_i_mns_1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i_pls_1</span> <span class="o">-</span> <span class="n">P_i</span>      <span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># c = np.sqrt(np.sum((P_i_pls_1 - P_i_mns_1)**2, axis=1))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i_pls_2</span> <span class="o">-</span> <span class="n">P_i_pls_1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i_pls_2</span> <span class="o">-</span> <span class="n">P_i</span>      <span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i_pls_2</span> <span class="o">-</span> <span class="n">P_i_mns_1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i_mns_2</span> <span class="o">-</span> <span class="n">P_i_mns_1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># reverse collections, for reverse tau</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">ee</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i_mns_2</span> <span class="o">-</span> <span class="n">P_i</span>      <span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">P_i_mns_2</span> <span class="o">-</span> <span class="n">P_i_pls_1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">4</span>

        <span class="c1"># Note that the index of a goes 0..n-5, and</span>
        <span class="c1"># Note that the index of kappa goes 0..n-3.</span>
        <span class="c1"># and P[i] corresponds to a[i] and kappa[i+1]</span>
        <span class="n">denom_ks</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="n">g</span>
        <span class="n">non_trivial</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom_ks</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kappa_s</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">kappa</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">kappa</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">kappa_s</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa_s</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span><span class="o">/</span><span class="n">denom_ks</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span>
        <span class="n">kappa_s</span><span class="p">[</span><span class="o">~</span> <span class="n">non_trivial</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        
      
        <span class="c1"># tau according to Boutin&#39;s \tilde{tau}_1, in the forward direction</span>
        <span class="n">tetra_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="n">kappa_s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tetrahedron</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">P_i_mns_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">P_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                                    <span class="n">P_i_pls_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">P_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                                    <span class="n">P_i_pls_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">P_i</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
            
            <span class="n">tetra_height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">tetrahedron</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># we want tau = 6 * tetra_height / denom_t, but </span>
        <span class="c1"># don&#39;t want to divide by zero, which happens if points repeat.</span>
        <span class="n">tau_fwd</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">tetra_height</span>
        <span class="n">denom_t</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">e</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">kappa</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># sign is inherited!</span>
        <span class="n">non_trivial</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom_t</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tetra_height</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tau_fwd</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau_fwd</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span> <span class="o">/</span> <span class="n">denom_t</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span>
        <span class="n">tau_fwd</span><span class="p">[</span><span class="o">~</span> <span class="n">non_trivial</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> 
        
        <span class="c1"># tau according to Boutin&#39;s \tilde{tau}_1, in the backard direction</span>
        <span class="n">tetra_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="n">kappa_s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tetrahedron</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">P_i_mns_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">P_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                                    <span class="n">P_i_mns_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">P_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                                    <span class="n">P_i_pls_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">P_i</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
            
            <span class="n">tetra_height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">tetrahedron</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># we want tau = 6 * tetra_height / denom_t, but </span>
        <span class="c1"># don&#39;t want to divide by zero, which happens if points repeat.</span>
        <span class="n">tau_bwd</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">tetra_height</span>
        <span class="n">denom_t</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">e</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">kappa</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># sign is inherited!</span>
        <span class="n">non_trivial</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom_t</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tetra_height</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tau_bwd</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau_bwd</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span> <span class="o">/</span> <span class="n">denom_t</span><span class="p">[</span><span class="n">non_trivial</span><span class="p">]</span>
        <span class="n">tau_bwd</span><span class="p">[</span><span class="o">~</span> <span class="n">non_trivial</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> 
        
        <span class="n">tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau_fwd</span> <span class="o">+</span> <span class="n">tau_bwd</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

       
        
<span class="c1">#        # tau_s according to Boutin&#39;s (17), in the forward direction</span>
<span class="c1">#        P_i_pls_3 = pos[4:, :]</span>
<span class="c1">#        h = np.sqrt(np.sum((P_i_pls_3 - P_i_pls_2[:-1])**2, axis=1))</span>
<span class="c1">#        dh = d[:-1] + h</span>
<span class="c1">#        denom_ts = denom_ks[1:-1] + dh</span>
<span class="c1">#        old_settings = np.seterr(divide=&#39;ignore&#39;)  #seterr to known value</span>
<span class="c1">#        tau_s_fwd = 4*(tau[1:] - tau[:-1] + (denom_ks[1:-1] -3*dh) * tau * kappa_s / (6 * kappa[2:-2]))/denom_ts</span>
<span class="c1">#        tau_s_fwd[denom_ts == 0] = 0</span>
<span class="c1">#        np.seterr(**old_settings)</span>
<span class="c1">#</span>
<span class="c1">#        # tau_s according to Boutin&#39;s (17), in the backward direction</span>
<span class="c1">#        P_i_mns_3 = pos[:-4, :]</span>
<span class="c1">#        h = np.sqrt(np.sum((P_i_mns_3 - P_i_mns_2[1:])**2, axis=1))</span>
<span class="c1">#        dh = d[1:] + h</span>
<span class="c1">#        denom_ts = denom_ks[1:-1] + dh</span>
<span class="c1">#        old_settings = np.seterr(divide=&#39;ignore&#39;)  #seterr to known value</span>
<span class="c1">#        tau_s_bwd = 4*(tau[1:] - tau[:-1] + (denom_ks[1:-1] -3*dh) * tau * kappa_s / (6 * kappa[2:-2]))/denom_ts</span>
<span class="c1">#        tau_s_bwd[denom_ts == 0] = 0</span>
<span class="c1">#        np.seterr(**old_settings)</span>
<span class="c1">#        </span>
<span class="c1">#        tau_s = (tau_s_fwd + tau_s_bwd)/2</span>

        <span class="k">assert</span> <span class="n">kappa</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,)</span>
        <span class="k">assert</span> <span class="n">kappa_s</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">4</span><span class="p">,)</span>
        <span class="k">assert</span> <span class="n">tau</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">4</span><span class="p">,)</span>
        <span class="c1">#assert tau_s.shape == (n-6,)</span>

        <span class="c1">#print(kappa.shape, tau_s.shape)</span>

        <span class="n">kappa_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">kappa_s_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">tau_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">tau_s_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        
        <span class="n">kappa_pad</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa</span>
        <span class="n">kappa_pad</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kappa_pad</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">kappa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">kappa_s_pad</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa_s</span>
        <span class="n">kappa_s_pad</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kappa_s_pad</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">kappa_s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">tau_pad</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
        <span class="n">tau_pad</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tau_pad</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">tau</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">tau_s_pad</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1">#tau_s_pad[2:-2] = tau_s</span>
        <span class="c1">#tau_s_pad[:2] = tau_s[0]</span>
        <span class="c1">#tau_s_pad[-2:] = tau_s[-1]</span>
        
        <span class="k">return</span> <span class="n">kappa_pad</span><span class="p">,</span> <span class="n">kappa_s_pad</span><span class="p">,</span> <span class="n">tau_pad</span><span class="p">,</span> <span class="n">tau_s_pad</span></div></div>

<span class="c1"># end of class SpaceCurve</span>
</pre></div>

          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2015-2017, Geometric Data Analytics, Inc.
      </li>
      <li>
      Last updated on Jan 07, 2019.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.2.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>